'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactQuery = require('@tanstack/react-query');
var server = require('@trpc/server');
var getArrayQueryKey = require('../getArrayQueryKey-5ab807a3.js');
var shared = require('@trpc/server/shared');
require('@trpc/client');
require('react');
var queryClient = require('../queryClient-358a9a75.js');

/**
 * Create functions you can use for server-side rendering / static generation
 * @deprecated use `createProxySSGHelpers` instead
 */ function createSSGHelpers(opts) {
    const { router , transformer , ctx  } = opts;
    const queryClient$1 = queryClient.getQueryClient(opts);
    const serialize = transformer ? ('input' in transformer ? transformer.input : transformer).serialize : (obj)=>obj;
    const prefetchQuery = async (...pathAndInput)=>{
        return queryClient$1.prefetchQuery(getArrayQueryKey.getArrayQueryKey(pathAndInput), ()=>{
            return server.callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const prefetchInfiniteQuery = async (...pathAndInput)=>{
        return queryClient$1.prefetchInfiniteQuery(getArrayQueryKey.getArrayQueryKey(pathAndInput), ()=>{
            return server.callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const fetchQuery = async (...pathAndInput)=>{
        return queryClient$1.fetchQuery(getArrayQueryKey.getArrayQueryKey(pathAndInput), ()=>{
            return server.callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    const fetchInfiniteQuery = async (...pathAndInput)=>{
        return queryClient$1.fetchInfiniteQuery(getArrayQueryKey.getArrayQueryKey(pathAndInput), ()=>{
            return server.callProcedure({
                procedures: router._def.procedures,
                path: pathAndInput[0],
                rawInput: pathAndInput[1],
                ctx,
                type: 'query'
            });
        });
    };
    function _dehydrate(opts = {
        shouldDehydrateQuery () {
            // makes sure to serialize errors
            return true;
        }
    }) {
        const before = reactQuery.dehydrate(queryClient$1, opts);
        const after = serialize(before);
        return after;
    }
    return {
        prefetchQuery,
        prefetchInfiniteQuery,
        fetchQuery,
        fetchInfiniteQuery,
        dehydrate: _dehydrate,
        queryClient: queryClient$1
    };
}

/**
 * Create functions you can use for server-side rendering / static generation
 */ function createProxySSGHelpers(opts) {
    const helpers = createSSGHelpers(opts);
    return shared.createFlatProxy((key)=>{
        if (key === 'queryClient') {
            return helpers.queryClient;
        }
        if (key === 'dehydrate') {
            return helpers.dehydrate;
        }
        return shared.createRecursiveProxy((opts)=>{
            const args = opts.args;
            const pathCopy = [
                key,
                ...opts.path
            ];
            const utilName = pathCopy.pop();
            const fullPath = pathCopy.join('.');
            switch(utilName){
                case 'fetch':
                    {
                        return helpers.fetchQuery(fullPath, ...args);
                    }
                case 'fetchInfinite':
                    {
                        return helpers.fetchInfiniteQuery(fullPath, ...args);
                    }
                case 'prefetch':
                    {
                        return helpers.prefetchQuery(fullPath, ...args);
                    }
                case 'prefetchInfinite':
                    {
                        return helpers.prefetchInfiniteQuery(fullPath, ...args);
                    }
            }
        });
    });
}

exports.createProxySSGHelpers = createProxySSGHelpers;
exports.createSSGHelpers = createSSGHelpers;
