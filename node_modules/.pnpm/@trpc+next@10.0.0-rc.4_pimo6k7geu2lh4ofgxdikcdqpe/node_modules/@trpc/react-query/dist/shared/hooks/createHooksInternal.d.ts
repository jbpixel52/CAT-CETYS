import { DehydratedState, UseInfiniteQueryOptions, UseInfiniteQueryResult, UseMutationOptions, UseMutationResult, UseQueryOptions, UseQueryResult } from '@tanstack/react-query';
import { CreateTRPCClientOptions, TRPCClient, TRPCClientErrorLike, TRPCRequestOptions } from '@trpc/client';
import type { AnyRouter, ProcedureRecord, inferHandlerInput, inferProcedureClientError, inferProcedureInput, inferProcedureOutput } from '@trpc/server';
import { inferObservableValue } from '@trpc/server/observable';
import { ReactNode } from 'react';
import { TRPCContextProps, TRPCContextState } from '../../internals/context';
import { CreateTRPCReactOptions } from '../types';
export declare type OutputWithCursor<TData, TCursor = any> = {
    cursor: TCursor | null;
    data: TData;
};
export interface TRPCReactRequestOptions extends Omit<TRPCRequestOptions, 'signal'> {
    /**
     * Opt out of SSR for this query by passing `ssr: false`
     */
    ssr?: boolean;
    /**
     * Opt out or into aborting request on unmount
     */
    abortOnUnmount?: boolean;
}
export interface TRPCUseQueryBaseOptions {
    /**
     * tRPC-related options
     */
    trpc?: TRPCReactRequestOptions;
}
export type { TRPCContext, TRPCContextState } from '../../internals/context';
export interface UseTRPCQueryOptions<TPath, TInput, TOutput, TData, TError> extends UseQueryOptions<TOutput, TError, TData, [TPath, TInput]>, TRPCUseQueryBaseOptions {
}
export interface UseTRPCInfiniteQueryOptions<TPath, TInput, TOutput, TError> extends UseInfiniteQueryOptions<TOutput, TError, TOutput, TOutput, [
    TPath,
    TInput
]>, TRPCUseQueryBaseOptions {
}
export interface UseTRPCMutationOptions<TInput, TError, TOutput, TContext = unknown> extends UseMutationOptions<TOutput, TError, TInput, TContext>, TRPCUseQueryBaseOptions {
}
export interface UseTRPCSubscriptionOptions<TOutput, TError> {
    enabled?: boolean;
    onStarted?: () => void;
    onData: (data: TOutput) => void;
    onError?: (err: TError) => void;
}
declare type inferInfiniteQueryNames<TObj extends ProcedureRecord> = {
    [TPath in keyof TObj]: inferProcedureInput<TObj[TPath]> extends {
        cursor?: any;
    } ? TPath : never;
}[keyof TObj];
declare type inferProcedures<TObj extends ProcedureRecord> = {
    [TPath in keyof TObj]: {
        input: inferProcedureInput<TObj[TPath]>;
        output: inferProcedureOutput<TObj[TPath]>;
    };
};
export interface TRPCProviderProps<TRouter extends AnyRouter, TSSRContext> extends TRPCContextProps<TRouter, TSSRContext> {
    children: ReactNode;
}
export declare type TRPCProvider<TRouter extends AnyRouter, TSSRContext> = (props: TRPCProviderProps<TRouter, TSSRContext>) => JSX.Element;
export declare type UseDehydratedState<TRouter extends AnyRouter> = (client: TRPCClient<TRouter>, trpcState: DehydratedState | undefined) => DehydratedState | undefined;
export declare type CreateClient<TRouter extends AnyRouter> = (opts: CreateTRPCClientOptions<TRouter>) => TRPCClient<TRouter>;
interface TRPCHookResult {
    trpc: {
        path: string;
    };
}
/**
 * @internal
 */
export declare type UseTRPCQueryResult<TData, TError> = UseQueryResult<TData, TError> & TRPCHookResult;
/**
 * @internal
 */
export declare type UseTRPCInfiniteQueryResult<TData, TError> = UseInfiniteQueryResult<TData, TError> & TRPCHookResult;
/**
 * @internal
 */
export declare type UseTRPCMutationResult<TData, TError, TVariables, TContext> = UseMutationResult<TData, TError, TVariables, TContext> & TRPCHookResult;
/**
 * Create strongly typed react hooks
 * @internal
 */
export declare function createHooksInternal<TRouter extends AnyRouter, TSSRContext = unknown>(config?: CreateTRPCReactOptions<TRouter>): {
    Provider: TRPCProvider<TRouter, TSSRContext>;
    createClient: CreateClient<TRouter>;
    useContext: () => TRPCContextState<TRouter, TSSRContext>;
    useQuery: <TPath extends keyof TRouter["_def"]["queries"] & string, TQueryFnData = inferProcedures<TRouter["_def"]["queries"]>[TPath]["output"], TData = inferProcedures<TRouter["_def"]["queries"]>[TPath]["output"]>(pathAndInput: [path: TPath, ...args: import("@trpc/server").ProcedureArgs<import("@trpc/server").inferProcedureParams<TRouter["_def"]["queries"][TPath]>>], opts?: UseTRPCQueryOptions<TPath, inferProcedures<TRouter["_def"]["queries"]>[TPath]["input"], TQueryFnData, TData, TRPCClientErrorLike<TRouter>> | undefined) => UseTRPCQueryResult<TData, TRPCClientErrorLike<TRouter>>;
    useMutation: <TPath_1 extends keyof TRouter["_def"]["mutations"] & string, TContext = unknown>(path: TPath_1 | [TPath_1], opts?: UseTRPCMutationOptions<inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["input"], TRPCClientErrorLike<TRouter>, inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["output"], TContext> | undefined) => UseTRPCMutationResult<inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["output"], TRPCClientErrorLike<TRouter>, inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["input"], TContext>;
    useSubscription: <TPath_2 extends keyof TRouter["_def"]["subscriptions"] & string, TOutput extends inferObservableValue<inferProcedureOutput<TRouter["_def"]["subscriptions"][TPath_2]>>>(pathAndInput: [path: TPath_2, ...args: import("@trpc/server").ProcedureArgs<import("@trpc/server").inferProcedureParams<TRouter["_def"]["subscriptions"][TPath_2]>>], opts: UseTRPCSubscriptionOptions<inferObservableValue<inferProcedureOutput<TRouter["_def"]["subscriptions"][TPath_2]>>, inferProcedureClientError<TRouter["_def"]["subscriptions"][TPath_2]>>) => void;
    useDehydratedState: UseDehydratedState<TRouter>;
    useInfiniteQuery: <TPath_3 extends inferInfiniteQueryNames<TRouter["_def"]["queries"]> & string>(pathAndInput: [path: TPath_3, input: Omit<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["input"], "cursor">], opts?: UseTRPCInfiniteQueryOptions<TPath_3, Omit<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["input"], "cursor">, inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["output"], TRPCClientErrorLike<TRouter>> | undefined) => UseTRPCInfiniteQueryResult<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["output"], TRPCClientErrorLike<TRouter>>;
};
/**
 * Hack to infer the type of `createReactQueryHooks`
 * @link https://stackoverflow.com/a/59072991
 */
declare class GnClass<TRouter extends AnyRouter, TSSRContext = unknown> {
    fn(): {
        Provider: TRPCProvider<TRouter, TSSRContext>;
        createClient: CreateClient<TRouter>;
        useContext: () => TRPCContextState<TRouter, TSSRContext>;
        useQuery: <TPath extends keyof TRouter["_def"]["queries"] & string, TQueryFnData = inferProcedures<TRouter["_def"]["queries"]>[TPath]["output"], TData = inferProcedures<TRouter["_def"]["queries"]>[TPath]["output"]>(pathAndInput: [path: TPath, ...args: import("@trpc/server").ProcedureArgs<import("@trpc/server").inferProcedureParams<TRouter["_def"]["queries"][TPath]>>], opts?: UseTRPCQueryOptions<TPath, inferProcedures<TRouter["_def"]["queries"]>[TPath]["input"], TQueryFnData, TData, TRPCClientErrorLike<TRouter>> | undefined) => UseTRPCQueryResult<TData, TRPCClientErrorLike<TRouter>>;
        useMutation: <TPath_1 extends keyof TRouter["_def"]["mutations"] & string, TContext = unknown>(path: TPath_1 | [TPath_1], opts?: UseTRPCMutationOptions<inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["input"], TRPCClientErrorLike<TRouter>, inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["output"], TContext> | undefined) => UseTRPCMutationResult<inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["output"], TRPCClientErrorLike<TRouter>, inferProcedures<TRouter["_def"]["mutations"]>[TPath_1]["input"], TContext>;
        useSubscription: <TPath_2 extends keyof TRouter["_def"]["subscriptions"] & string, TOutput extends inferObservableValue<inferProcedureOutput<TRouter["_def"]["subscriptions"][TPath_2]>>>(pathAndInput: [path: TPath_2, ...args: import("@trpc/server").ProcedureArgs<import("@trpc/server").inferProcedureParams<TRouter["_def"]["subscriptions"][TPath_2]>>], opts: UseTRPCSubscriptionOptions<inferObservableValue<inferProcedureOutput<TRouter["_def"]["subscriptions"][TPath_2]>>, inferProcedureClientError<TRouter["_def"]["subscriptions"][TPath_2]>>) => void;
        useDehydratedState: UseDehydratedState<TRouter>;
        useInfiniteQuery: <TPath_3 extends inferInfiniteQueryNames<TRouter["_def"]["queries"]> & string>(pathAndInput: [path: TPath_3, input: Omit<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["input"], "cursor">], opts?: UseTRPCInfiniteQueryOptions<TPath_3, Omit<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["input"], "cursor">, inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["output"], TRPCClientErrorLike<TRouter>> | undefined) => UseTRPCInfiniteQueryResult<inferProcedures<TRouter["_def"]["queries"]>[TPath_3]["output"], TRPCClientErrorLike<TRouter>>;
    };
}
declare type returnTypeInferer<TType> = TType extends (a: Record<string, string>) => infer U ? U : never;
declare type fooType<TRouter extends AnyRouter, TSSRContext = unknown> = GnClass<TRouter, TSSRContext>['fn'];
/**
 * Infer the type of a `createReactQueryHooks` function
 * @internal
 */
export declare type CreateReactQueryHooks<TRouter extends AnyRouter, TSSRContext = unknown> = returnTypeInferer<fooType<TRouter, TSSRContext>>;
//# sourceMappingURL=createHooksInternal.d.ts.map